# OB04
 SOLID

Задание: Применение Принципа Открытости/Закрытости (Open/Closed Principle) в Разработке Простой Игры
Цель: Цель этого домашнего задание - закрепить понимание и навыки применения принципа открытости/закрытости
(Open/Closed Principle), одного из пяти SOLID принципов объектно-ориентированного программирования. Принцип гласит, что
программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.
Задача: Разработать простую игру, где игрок может использовать различные типы оружия для борьбы с монстрами. Программа
должна быть спроектирована таким образом, чтобы легко можно было добавлять новые типы оружия, не изменяя существующий
код бойцов или механизм боя.
Исходные данные:
- Есть класс `Fighter`, представляющий бойца.
- Есть класс `Monster`, представляющий монстра.
- Игрок управляет бойцом и может выбирать для него одно из вооружений для боя.
Шаг 1:Создайте абстрактный класс для оружия
- Создайте абстрактный класс `Weapon`, который будет содержать абстрактный метод `attack()`.
Шаг 2: Реализуйте конкретные типы оружия
- Создайте несколько классов, унаследованных от `Weapon`, например, `Sword` и `Bow`. Каждый из этих классов реализует
метод `attack()` своим уникальным способом.
Шаг 3: Модифицируйте класс `Fighter`
- Добавьте в класс `Fighter` поле, которое будет хранить объект класса `Weapon`.
- Добавьте метод `changeWeapon()`, который позволяет изменить оружие бойца.
Шаг 4: Реализация боя
- Реализуйте простой механизм для демонстрации боя между бойцом и монстром, исходя из выбранного оружия.
Требования к заданию:
- Код должен быть написан на Python.
- Программа должна демонстрировать применение принципа открытости/закрытости: новые типы оружия можно легко добавлять,
не изменяя существующие классы бойцов и механизм боя.
- Программа должна выводить результат боя в консоль.
Пример результата:
Боец выбирает меч.
Боец наносит удар мечом.
Монстр побежден!
Боец выбирает лук.
Боец наносит удар из лука.
Монстр побежден!

## Описание классов

***Monster(health=100, damage=8, distance=25)*** - класс, представляющий монстра. Имеет параметры по умолчанию: здоровье, урон и расстояние до монстра соответственно. Последний на всякий случай преобразуется функцией *abs()*. При первом вызове объекта отображает расстояние, то есть значение параметра *distance*. Также у класса есть два метода:
- *.attack(fighter)* - ожидает в аргументы объект класса *Fighter*. Поведение метода зависит от указанного параметра *distance*: при значении больше 1 - параметр уменьшается на единцу; при значении 0 - параметр увеличивается на 1; при значении 1 - вызывается метод указанного в аргументе объекта класса *Fighter .take_damage(damage)*, где *damage* это параметр объекта класса *Monster*;
- *.take_damage(damage)* - метод уменьшает параметр *health* на количество *damage*. Метод вызывается при использовании метода *.attack()* объектов класса *Weapon*.

Есть три класса, производных от абстрактного класса *Weapon()*. У каждого своя реализация метода *.attack(monster)*, где *monster* - объект класса *Monster*, вызывает метод этого объекта *.take_damage(damage)*, где *damage* - значение параметра классов оружия *damage*. А также метод __str__(), выводящий текущее состояние объекта при передаче его в функцию *print*:
- *Sword()* - представляет оружие ближнего боя. Метод *.attack(monster)* при значении параметра объекта *monster.distance* равному единице - наносит урон в размере 5, в остальных случаях ничего не делает. Атрибут *ammo* всегда *True*;
- *Bow()* - оружие дальнего боя. Метод *.attack(monster)* при значении параметра объекта *monster.distance* <=  12 - наносит урон в размере 4, и не зависимо от этого параметра уменьшает атрибут *ammo* на единицу (изначально 10). При достижении значения атрибута 0 - выводит сообщение о необходимости смены оружия;
- *Rifle()* - оружие дальнего боя. Метод *.attack(monster)* при значении параметра объекта *monster.distance* <=  20 - наносит урон в размере 6, и не зависимо от этого параметра уменьшает атрибут *ammo* на единицу (изначально 5). При достижении значения атрибута 0 - выводит сообщение о необходимости смены оружия.

***Fighter(\*args: Weapon, health=50)*** - ожидает в аргументы произвольное количество объектов класса Weapon, а также имеет параметр *health* по умолчанию равный 50. При первом вызове отображает выбранное оружие и его состояние - первое оружие выбирается случайным образом. Методы класса:
- *move(monster)* - тут *monster* - объект класса *Monster*,Вызывает метод этого объекта *monster.attack()*. Рекомендуется применять только в случаях, когда параметр *monster.distance* больше атрибутов *range* объектов *Weapon*, или при достижении атрибутов *ammo* объектов *Weapon* значения 0, заблаговременно выбрав оружие ближнего боя;
- *.take_damage(damage)* - метод уменьшает параметр *health* на количество *damage*. Метод вызывается при использовании метода *.attack()* объектов класса *Monster*; 
- *change_weapon()* - выводит нумерованный список объектов класса *Weapon* и их текущее состояние. Ожидает ввод от пользователя - соответствующую списку цифру, после чего используемое оружие поменяется на выбор пользователя.

### Запуск игры
Для удобства тестирования добавлен цикл с нумерованным выбором действий:
- атаковать выбранным оружием, при этом дистанция сокращается на 1;
- поменять оружие - возможность выбрать оружие из имеющегося в списке *.arsenal*. Дистанция сократится на 1;
- приблизиться к врагу - дистанция сократится на 2. Если дистанция меньще 3 воин получит урон:
  - при дистанции 2 - один раз;
  - при дистанции 1 - дважды.













